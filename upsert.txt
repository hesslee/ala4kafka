"DECLARE " +
"   r1 "ttt123"%ROWTYPE; " +
"BEGIN " +
"        r1.c1 := ?; " +
"        r1.c2 := ?; " +
"        r1.c3 := ?; " +
"        INSERT INTO "test-purchases" VALUES r1; " +  
"EXCEPTION " +
"WHEN DUP_VAL_ON_INDEX THEN " +
"        update "test-purchases" set c2 = r1.c2, c3 = r1.c3 where c1 = r1.c1 ; " +
"END;"

    ExpressionBuilder builder = expressionBuilder();
    builder.append("declare ");
    builder.append("r1 "); builder.append(table); builder.append("%rowtype; ");
    builder.append("begin ");
    builder.appendList()
           .delimitedBy(", ")
           .transformedBy(ExpressionBuilder.columnNamesWithPrefix("? "))
           .of(keyColumns, nonKeyColumns);
    builder.append(" FROM dual) incoming on(");
 
drop table "test-purchases";
CREATE TABLE "test-purchases" (
"c1" INT PRIMARY KEY ,
"c2" VARCHAR(20),
"c3" int
);

CREATE OR REPLACE PROCEDURE proc1
AS
    r1 "ttt123"%ROWTYPE;
BEGIN
    FOR i IN 1 .. 5 LOOP
        r1.i1 := i+10;
        r1.i2 := i+20;
        r1.i3 := i+30;
        INSERT INTO "ttt123" VALUES r1;
    END LOOP;
END;
/

  // merge into "test-altibase-USERS" using (select ? "ID", ? "NAME" FROM dual) incoming on("test-altibase-USERS"."ID"=incoming."ID") 
  // when matched then update set "test-altibase-USERS"."NAME"=incoming."NAME" 
  // when not matched then insert("test-altibase-USERS"."NAME","test-altibase-USERS"."ID") values(incoming."NAME",incoming."ID")


  @Override
  public String buildUpsertQueryStatement(
      final TableId table,
      Collection<ColumnId> keyColumns,
      Collection<ColumnId> nonKeyColumns
  ) {
    final Transform<ColumnId> transform = (builder, col) -> {
      builder.append(table)
             .append(".")
             .appendColumnName(col.name())
             .append("=incoming.")
             .appendColumnName(col.name());
    };
 
    ExpressionBuilder builder = expressionBuilder();
    builder.append("merge into ");
    builder.append(table);
    builder.append(" using (select ");
    builder.appendList()
           .delimitedBy(", ")
           .transformedBy(ExpressionBuilder.columnNamesWithPrefix("? "))
           .of(keyColumns, nonKeyColumns);
    builder.append(" FROM dual) incoming on(");
    builder.appendList()
           .delimitedBy(" and ")
           .transformedBy(transform)
           .of(keyColumns);
    builder.append(")");
    if (nonKeyColumns != null && !nonKeyColumns.isEmpty()) {
      builder.append(" when matched then update set ");
      builder.appendList()
             .delimitedBy(",")
             .transformedBy(transform)
             .of(nonKeyColumns);
    }
 
    builder.append(" when not matched then insert(");
    builder.appendList()
           .delimitedBy(",")
           .of(nonKeyColumns, keyColumns);
    builder.append(") values(");
    builder.appendList()
           .delimitedBy(",")
           .transformedBy(ExpressionBuilder.columnNamesWithPrefix("incoming."))
           .of(nonKeyColumns, keyColumns);
    builder.append(")");
    return builder.toString();
  }
}
